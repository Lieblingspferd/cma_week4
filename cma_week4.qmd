---
title: "cma_week4"
author: "Annika Hirsch"
format: html
execute: 
  warning: false
  message: false
lang: en
editor: visual
---

**Tasks:**

a\. Specify a temporal windows v for in which to measure Euclidean distances.

b\. Measure the distance from every point to every other point within this temporal window v.

c\. Remove “static points”: These are points where the average distance is less than a given threshold. This segments the trajectory into subtrajectories.

d\. Now remove short subtrajectories: These are trajectories with a short duration (whereas “short” is tbd).

# Demo

```{r}
library("readr")
library("dplyr")
library("sf")
library("ggplot2")

wildschwein <- read_delim("wildschwein_BE_2056.csv", ",")

# Careful! What Timezone is assumed?
sabi <- wildschwein |>
    st_as_sf(coords = c("E", "N"), crs = 2056, remove = FALSE) |>
    filter(TierName == "Sabi", DatetimeUTC >= "2015-07-01", DatetimeUTC < "2015-07-03")
```

## Task a

I am choosing a temporal window, as suggested, of one hour.

## Task b

```{r}
distance_by_element <- function(later, now) {
  as.numeric(
    st_distance(later, now, by_element = TRUE)
  )
}

sabi <- sabi |>
    mutate(
        nMinus2 = distance_by_element(lag(geometry, 2), geometry),  # distance to pos -30 minutes
        nMinus1 = distance_by_element(lag(geometry, 1), geometry),  # distance to pos -15 minutes
        nPlus1  = distance_by_element(geometry, lead(geometry, 1)), # distance to pos +15 mintues
        nPlus2  = distance_by_element(geometry, lead(geometry, 2))  # distance to pos +30 minutes
    )
```

```{r}
sabi <- sabi |>
    rowwise() |>
    mutate(
        stepMean = mean(c(nMinus2, nMinus1, nPlus1, nPlus2))
    ) |>
    ungroup()

sabi
```

## Task c

```{r}
sabi <- sabi |>
    mutate(static = stepMean < mean(stepMean, na.rm = TRUE))

sabi_filter <- sabi |>
    filter(!static)

sabi_filter |>
    ggplot(aes(E, N)) +
    geom_path() +
    geom_point() +
    coord_fixed() +
    theme(legend.position = "bottom")
```

# Project data

## Preparation

```{r}
library("FITfileR")

activity <- readFitFile("kurz_auf_den_harder.fit")

activity

activity_records <- records(activity)
activity_records

# Transform into sf
activity_sf <- st_as_sf(activity_records[["record_1"]],
                        coords = c("position_long", "position_lat"),
                        crs = 4326
)

# Change crs
activity_sf <- st_transform(activity_sf, crs = 2056)

coords <- st_coordinates(activity_sf)

activity_sf <- cbind(activity_sf, coords)


library("tmap")

# Visualisation
tmap_mode("view")

# Create a line
activity_line <- activity_sf %>%
  summarise(do_union = FALSE) %>% 
  st_cast("LINESTRING")

# Change basemap
tmap_options(basemaps = "OpenStreetMap")

# Plot map
tm_shape(activity_line) +
  tm_lines() 
```

The data that I imported already is only from one day (more like less than 2 hours), so I am not going to shorten it even more (though it would be interesting to just look at the downhill parts).

But I am going to delete the points where the GPS accuracy is higher than 30, because these point are at the beginning and the end of the activity and it seems, as if I was inside for these points.

```{r}
activity_sf <- subset(activity_sf, activity_sf$gps_accuracy<= 30)
```

## Task 1: Segmentation

Implementation of steps a, b and c of the demo data.

The temporal sampling rate seems to be around 1 second. So as my window I am going to choose 10 seconds:

pos\[n-5\] to pos\[n\]

...

pos\[n-1\] to pos\[n\]

pos\[n\] to pos\[n+1\]

...

pos\[n\] to pos\[n+5\]

```{r}
distance_by_element <- function(later, now) {
  as.numeric(
    st_distance(later, now, by_element = TRUE)
  )
}

activity_sf <- activity_sf |>
    mutate(
        nMinus5 = distance_by_element(lag(geometry, 5), geometry), 
        nMinus4 = distance_by_element(lag(geometry, 4), geometry),  
        nMinus3 = distance_by_element(lag(geometry, 3), geometry),  
        nMinus2 = distance_by_element(lag(geometry, 2), geometry),  
        nMinus1 = distance_by_element(lag(geometry, 1), geometry),  
        nPlus1  = distance_by_element(geometry, lead(geometry, 1)), 
        nPlus2  = distance_by_element(geometry, lead(geometry, 2)),
        nPlus3  = distance_by_element(geometry, lead(geometry, 3)),
        nPlus4  = distance_by_element(geometry, lead(geometry, 4)),
        nPlus5  = distance_by_element(geometry, lead(geometry, 5)),
    )

activity_sf <- activity_sf |>
    rowwise() |>
    mutate(
        stepMean = mean(c(nMinus5, nMinus4, nMinus3, nMinus2, nMinus1, nPlus1, nPlus2, nPlus3, nPlus4, nPlus5))
    ) |>
    ungroup()

activity_sf
```

## Task 2: Specify and apply threshold d

Considering, that this was a mountainbiking activity, there should not be many static points, since this was a route that I already knew. The only static points should be breaks or waiting for hikers to pass. I do not think that using the mean value as threshold is going to work.

I am checking the distribution of speed.

```{r}
hist(activity_sf$stepMean)
```

Judging from this, I am going to test with a threshold value of 1.

```{r}
activity_sf <- activity_sf |>
    mutate(static = stepMean < 1)

activity_filter <- activity_sf |>
    filter(!static)

activity_filter |>
    ggplot(aes(X, Y)) +
    geom_path() +
    geom_point() +
    coord_fixed() +
    theme(legend.position = "bottom")
```

```{r}
hist(activity_filter$stepMean)
```

Seems to be a good threshold.

## Task 3: Visualize segmented trajectories

Now visualize the segmented trajectory spatially. Just like last week, you can use ggplot with `geom_path()`, `geom_point()` and `coord_equal()`. Assign `colour = static` within `aes()` to distinguish between segments *with* “movement” and *without*.

```{r}
activity_sf |>
    ggplot(aes(X, Y, color = static)) +
    geom_path() +
    geom_point() +
    coord_equal() +
    theme(legend.position = "bottom")
```

## Task 4: Segment-based analysis

```{r}
rle_id <- function(vec) {
    x <- rle(vec)$lengths
    as.factor(rep(seq_along(x), times = x))
}
```

```{r}
activity_sf <- activity_sf |>
    mutate(segment_id = rle_id(static))

activity_sf |>
    ggplot(aes(X, Y, color = segment_id)) +
    geom_path() +
    geom_point() +
    coord_equal() #+ # the legend makes the plot illegible
    #theme(legend.position = "bottom")
```

I am now supposed to remove short segments. In the task description they are classified as shorter than 5 min, but knowing the characteristics of my activity, that does not make sense here. So I am going to look at the data to determine short segments:

```{r}
plot(table(activity_sf$segment_id))
```

```{r}
# Deleting the segments which have less than 10 points
segment_filter <- activity_sf[activity_sf$segment_id %in% names(which(table(activity_sf$segment_id) > 10)), ]

# Checkin the lengths:
plot(table(segment_filter$segment_id))

# Now plotting this:
segment_filter |>
    ggplot(aes(X, Y, color = segment_id)) +
    geom_path() +
    geom_point() +
    coord_equal()
```
